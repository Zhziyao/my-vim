"[vim 内置文档]
":h vimtutor

"[提示符]
"$ 外部shell执行命令行命令
": 命令行模式执行 Ex 命令
"/ 命令行模式执行正向查找
"? 命令行模式执行反向查找
"= 命令行模式对一个vim脚本表达式求值

"[无插件启动vim]
"$ vim -u NONE -N
"[说明]:	-u NONE 不加载vimrc， -N nocompatible
"[最小插件启动vim]
"[essential.vim] 
"set nocompatible
"filetype plugin on
"$ vim -u essential.vim

"[vim理念]
"工作的重复性。学会规划按键动作，使得在重复时能完成一项有用的工作。
"[.命令]
"重复上次修改
"[一键移动，另一键操作]
"
"就像画家只花一小部分时间涂色一样，程序员只花一小部分时间编写代码。绝大多数时间用来思考、阅读，以及代码中穿梭浏览。当确实需要时，修改代码,重新调整已有代码的格式。


"[按键映射]
"		COMMANDS				MODES
":map   :noremap  :unmap     Normal, Visual, Select, Operator-pending
":nmap  :nnoremap :nunmap    Normal
":vmap  :vnoremap :vunmap    Visual and Select
":smap  :snoremap :sunmap    Select
":xmap  :xnoremap :xunmap    Visual
":omap  :onoremap :ounmap    Operator-pending
":map!  :noremap! :unmap!    Insert and Command-line
":imap  :inoremap :iunmap    Insert
":lmap  :lnoremap :lunmap    Insert, Command-line, Lang-Arg
":cmap  :cnoremap :cunmap    Command-line

"[插件]
"https://github.com/tpope/vim-commentary				为vim支持的语言增添注释以及解注释的命令
"https://github.com/kana/vim-textobj-entire				增添两种新的文本对象类型ie ae 作用于整个文件
"https://github.com/tpope/vim-unimpaired				映射 缓冲区列表b、参数列表a、quickfix列表q、位置列表l、标签列表t
"														netrw插件浏览目录树的内容
"https://github.com/tpope/vim-rails						使用rails.vim进行智能路径管理
"https://github.com/tpope/vim-surround					匹配括号间的跳转和内容修改
"https://github.com/tpope/vim-abolish					超级substitute命令


"[普通模式]________________________________________________________________________________________________________________________________
"u				撤销上次修改
"i				进入插入模式
"a				光标后插入
"A				行尾插入
"<Esc>			返回普通模式
"^				移动到行首，第一个非空字符
"0				移动到行首
"$				移动到行尾
"2G				跳到第二行（Goto）

"zz				重绘屏幕，使当前行处于屏幕正中
"K				查看处于光标下的那个单词的手册页
"J				将当前行和下一行连接在一起
"ga				获取光标下字符的编码

"*				正向查找当前光标下的单词
"#				反向查找当前光标下的单词
"				（基于单词的移动）
"b				移动到单词开头
"B				移动到字符串text的头
"w				移动到下一个单词的头
"W				移动到下一个字符串text的头
"e				移动到单词结尾
"E				移动到下一个字符串text结尾
"ge				反向移动到上一个单词结尾
"				（文本范围）
"w				一个单词
"aw				一个单词加上与其他单词之间的空格

"<C-a>			对数字执行加法
"<C-x>			对数字执行减法
"如:			180<C-x>
"set nrformats=					设置0开头的数字的进制体系

"C				c$				删除当前光标处至行尾，并插入		
"s				cl				删除当前字符，并插入
"S				^C				删除当前行，并插入
"I				^i				行首插入
"A				$a				行尾插入
"o				A<CR>			在下一行插入
"O				ko				在上一行插入

"f{char}/t{char}		行内向下查找字符
"F{char}/T{char}		行内向上查找字符
";						重复f{char}/t{char}
"，						回退f{char}/t{char}

"/Pattern<CR>			文档中向下查找字符串
"?pattern<CR>			文档内向上查找字符串
"n						重复/pattern<CR>
"N						回退/pattern<CR>

":s/target/replacemnet	执行替换
"&						重复:s
"u						撤销:s

"[执行一系列修改]（操作宏）
"qx{changes}q			执行一系列修改
"@x						重复qx{changes}q
"u						撤销qxq

"@:						重复上次EX命令（命令行命令）
"&						重复:substitute命令

"[操作符 + 动作命令 = 操作]
"[作用范围motion]
"d{motion}				dl{字符} daw{单词} dap{段落}
"c{motion}				cl		 caw	   cap
"y{motion}				yl		 yaw	   yap
"额外规则:当一个操作符命令被连续调用两次时，它作用于当前行。

"[操作符]
"c						修改
"d						delete
"y						yank（复制到寄存器）
"g~						反转大小写
"gu						转换为小写
"gU						转换为大写
">						增加缩进
"<						减小缩进
"=						自动缩进
"!						使用外部程序过滤{motion}所跨越的行

"[操作符待决模式]
"操作符已被激活，等待输入motion
"<Esc>终止操作符待决，返回普通模式


"[插入模式]———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
"[理念]
"盲打并不仅仅指输入时不看键盘，还意味着输入时要凭感觉。
"专业打字员会建议先删除整个单词，然后再重新输入一遍。

"[按键操作]
"<C-h>					删除前一个字符
"<C-w>					删除前一个单词
"<C-u>					删至行首

"<Esc>					切换到普通模式
"<C-[>					切换到普通模式
"<C-o>					切换到插入-普通模式[核心]
"如:<C-o>zz				用途:在插入过程中刷新屏幕，使保持在正中位置。

"[粘贴寄存器中内容]
"<C-r>{寄存器地址}			
"<C-r><C-p>{寄存器地址}		<C-r>{}的智能版本，按原义插入寄存器内容，并修正任何不必要的缩进。

"[寄存器]
"=							表达式寄存器
"							无名寄存器
"							有名寄存器
"+							系统剪贴板
"*							主剪贴板
"							黑洞寄存器
"							复制专用寄存器（0）

"[使用字符编码插入字符]
"<C-v>{code}
"065						十进制
"u00bf						十六进制
"获取光标下字符的编码:		ga
"特例:						如果<C-v>之后的输入为非数字，则插入按键本身代表的字符。(如:<C-v><Tab> 插入Tab)
"[总结]
"<C-v>{123}					以十进制编码插入字符
"<C-v>u{1234}				以十六进制编码插入字符
"<C-v>{nondigit}			按原义插入非数字字符
"<C-v>{char1}{char2}		插入以二合一表示的字符


"[替换模式]_______________________________________________________________________________________________________________________________
"R							由普通模式进入替换模式
"<Insert>					在插入模式与替换模式间切换
"<Esc>						返回普通模式
"[虚拟替换模式]
"gR							与R的区别是，将制表符当作多个字符，即一组空格。按屏幕上实际显示的宽度来替换字符。
"[针对字符的替换]
"r{char}					由普通模式进入字符替换模式（常用命令）
"gr{char}					由普通模式进入虚拟字符替换模式


"[可视模式]_______________________________________________________________________________________________________________________________
"[理念]
"顾名思义，可视模式仅仅是另外一种模式，也就是说在此模式中，每个按键完成一种不同的功能。

"[可视模式下的跳转指令]
"h，j，k，l
"f{char}/t{char} F{char}/T{char}	; ,
"/pattern<CR> ?pattern<CR>			n N

"[motion+操作符=操作]
"[核心工具]

"[激活可视模式]
"v							面向字符的可视模式
"V							面向行的可视模式
"<C-v>						面向列的可视模式
"gv							重选上次的选取

"<Esc> <C-[>				返回普通模式
"o							切换高亮选区的活动端

"[选择模式]
"在此模式下，输入的可见字符替换选中的文本，并进入插入模式。
"<C-g>						在可视模式与选择模式之间切换


"[命令行模式]_____________________________________________________________________________________________________________________________
":							从普通模式进入命令行模式
"@:							重复上一次的Ex命令
"[理念]
"将vim的普通命令与Ex的大范围结合起来。

"[命令]
":edit						读文件
":write						写文件
":update					写文件，有修改时
":split						分割窗口
":prev/:next				操作参数列表
":bprev/:bnext				操作缓冲区列表

":[range]delete [x]										删除指定的行 [到寄存器x]
":[range]yank	[x]										复制指定的行 [到寄存器x]
":[line]put		[x]										在指定行后粘贴寄存器x中的内容
":[range]copy	{address}								将指定的行拷贝到{address}指定的行之下
":[range]move	{address}								将指定的行移动到{address}指定的行之下
":[range]join											连接指定范围内的行
":[range]normal	{commands}								对选定的每一行执行普通模式命令
":[range]substitute/{pattern}/{string}/[flags]			范围内的pattern替换为string
":[range]global/{pattern}/[cmd]							范围内的pattern执行Ex命令{cmd}

"[命令行模式比普通模式的优势]
"相比普通模式，Ex命令拥有能够在多行上同时执行的能力。

"[行号指定{range}]
":{start},{end}											如:	:3,5
"[特殊符号]
":.														当前行的地址
":$														文件的末尾
":%														文件的所有行

"[模式指定{range}]
":/pattern/,/pattern/

"[用偏移对行地址修改]
":/pattern/+1,/pattern/-1

"[总结]
"1							文件的第一行
"$							文件的最后一行
"0							虚拟行，位于文件第一行的上方
".							光标所在行
"'m							包含位置标记m的行
"'<							选区的起始行
"'>							选区的结束行
"%							整个文件（:1,$ 的简写形式）
"注意: 在定义一个range时，总代表一系列连续行。

"[命令简写]
":copy						:co :t
":move						:m

"[多行上同时执行.范式]
":'<,'>normal .
"[多行上添加注释]
":'<,'>normal I//

"[列表浏览]
":bn
":bp
"@:							重复执行Ex
"<C-o>						回退Ex

"[Ex命令补全]
"<Tab>						正向遍历
"<S-Tab>					反向遍历
"<C-d>						列出所有可选项

"[在命令行中，将光标所在单词插入命令行]
":<C-r><C-w>
"[在命令行中，插入光标下字串]
":<C-r><C-a>


"[命令行窗口]_____________________________________________________________________________________________________________________________
"q:										打开Ex命令行窗口
"q/										打开pattern命令行窗口
"<C-f>									从命令行模式切换到命令行窗口
":q										退出命令行窗口


"[运行shell命令]__________________________________________________________________________________________________________________________
":!{cmd}								在shell中运行cmd
":shell									启动一个交互式shell，exit返回vim
"[说明]: 在shell命令中，%代表当前文件名

"<Ctrl-z>								挂起当前进程，返回bash shell
"$jobs									查看当前的进程作业列表
"fg										唤醒挂起的进程

":read  !{cmd}							命令行cmd的输出定向到缓冲区
":write !{cmd}							缓冲区内容作为cmd的标准输入
":write! {file}							将缓冲区写到文件file，！表示覆盖原文件

"[使用shell命令过滤缓冲区内容]
":[range]!{filter}
"如:	:2,$!sort -t',' -k2
"-t',' 说明每个记录以逗号分隔
"-k2   指定按第二个字段排序


"[批处理运行Ex命令]_______________________________________________________________________________________________________________________
"[vim脚本]	扩展名	.vim
"如 [batch.vim]
":g/href/j
":v/href/d
":%norm A: http://vimcasts.org
":%norm yi"$p
":%s/\v^[^\v]+\>\s//g
"[执行vim脚本]	:source	batch.vim
"[多个文件执行同一个脚本]
"$vim *.html
":args									显示当前的文件参数列表
":argdo source batch.vim				当前参数列表中的文件都执行vim脚本


"[多文件管理]_____________________________________________________________________________________________________________________________
":args									显示参数列表（参数列表）
":argdo									每个文件上执行Ex命令
":bufdo									在ls列出的所有缓冲区上执行Ex命令（缓冲区列表）

"[缓冲区列表]___________________________
":ls									列出缓冲区列表
":bnext									切换到下一个缓冲区
":bprev									切换到上一个缓冲区
":bfirst								跳转到第一个缓冲区
":blast									跳转到最后一个缓冲区
":buffer N								跳转到指定缓冲区
":buffer {bufname}						跳转到指定缓冲区
":bdelete N1 N2 N3						删除缓冲区

"[说明符]
"%										表示缓冲区在当前窗口可见
"#										代表轮换文件
"<C-^>									%缓冲区与#缓冲区之间来回切换

"[参数列表]_____________________________
"[优势] 参数列表易于管理，适用于对一批文件进行分组，使其更容易访问。
":args									args列表并不一定反映启动vim时所传的参数
":args {arglist}						{arglist}可以包括文件名、通配符，甚至是一条shell命令的输出结果
":next
":prev

"[往参数列表中添加文件]
":args {arglist}
":args **/*.*

"[清空并重新设置参数列表]
":args {arglist}						一下清空并重新设置参数列表为{arglist}

"[说明符]
"*										匹配0个字符或多个字符
"**										匹配0个字符或多个字符，但递归进入指定目录的子目录
"``										vim会在shell中执行反撇号括起来的命令

"[管理被修改过的缓冲区__________________
":ls									查看当前所有缓冲区状态
":set hidden							启用hidden，就可以不带！执行缓冲区切换

"[说明符]
"+										表示缓冲区被修改过
"a										表示当前是活动缓冲区（active）
"h										表示是隐藏缓冲区（hidden）

"[在退出时处理隐藏缓冲区]
":write									缓冲区保存到文件
":edit!									重新从磁盘读取文件，覆盖缓冲区
":quit									退出
":quit!									放弃修改，退出
":qall!									放弃修改，退出所有
":wall									保存所有修改
"[缩写]									:w :e :qa :wa

"[将工作区切分成窗口]___________________
"[创建分割窗口]
":<C-w>s								水平切分窗口
":<C-w>v								垂直切分窗口
":split  {file}							水平切分窗口
":vsplit {file}							垂直切分窗口

"[在窗口间切换]
"<C-w>w	/ 按住<ctrl>ww					窗口间循环切换
"<C-w>h / 按住<ctrl>wh
"<C-w>j / 按住<ctrl>wj
"<C-w>k / 按住<ctrl>wk
"<C-w>l / 按住<ctrl>wl
"<C-w>c									:close
"<C-w>o									:only

"[关闭窗口]
":close									关闭当前窗口
":only									关闭其他所有窗口

"[重排列窗口]
"<C-w>=									所有窗口等宽、等高
"<C-w>_									最大化活动窗口的高度
"<C-w>|									最大化活动窗口的宽度
"[N]<C-w>_								把活动窗口的高度设置为N行
"[N]<C-w>|								把活动窗口的宽度设置为N列

"[打开新的标签页]_______________________
":tabedit
":tabedit {filename}					打开新的标签页，打开一个缓冲区
":tabclose								关闭当前标签页
":tabonly								关闭其他所有标签页
":<C-w>T								把当前窗口移到一个新的标签页

"[在标签页之间切换]
"[Ex命令]								[普通模式命令]						[用途]
":tabn	{N}								{N}gt								切换到编号为{N}的标签页
":tabn									gt									下一个标签页
":tabp									gT									上一个标签页
":tabmove {N}																改变当前标签页的编号，重排标签页

"[设置当前窗口的本地工作目录]
":lcd {path}							设置当前窗口的本地工作目录
":windo lcd {path}						设置标签页内所有窗口的本地工作目录

"[打开、保存文件]_______________________
"[vim的工作目录]
":pwd									打印工作目录

":edit {file}							打开文件
":find {file}							在path中查找文件并打开（工程管理）
":set path+=**/**						设置:find的查找路径

"[获取活动缓冲区文件路径]_______________
"%<Tab>									活动缓冲区的完整文件路径
"%:h<Tab>								去除文件名，保存路径中的其他部分

"[netrw管理文件系统]____________________（工程管理）
"$vim .									打开目录,打开文件管理器
":edit {path}							打开目录,打开文件管理器（缩写 :e.）
":Explore								打开当前文件所在目录，打开文件管理器（缩写 :E）
":Sexplore								水平切分窗口，打开文件管理器
":Vexplore								垂直切分窗口，打开文件管理器
"-										返回上级目录
"光标处于.. <CR>						返回上级目录

"[工程目录树]___________________________
"[与分割窗口协同工作]
"Vimcasts 专题15 对netrw进行了深入的讲解
":h netrw-%								创建新文件
":h netrw-d								创建新目录
":h netrw-rename						重命名已有文件及目录
":h netrw-del							删除已有文件及目录

"[把文件保存到不存在的目录]_____________
"<C-g>									查看当前文件的状态
"[当指定的文件路径中包含尚未存在的目录时，:write命令就无法执行]
":!mkdir -p %:h							创建任何不存在的中间目录（创建中间目录）

"[以超级用户权限保存文件]_______________
":w !sudo tee % > /dev/null				（获取sudo权限）


"[更快的移动及跳转]_______________________________________________________________________________________________________________________
"[动作命令]（motion）	:h motion.txt
"[作用]: 移动光标、与操作符待决模式配合使用，指定文本范围

"[光标移动]
"h，j，k，l								光标移动

"[实际行与屏幕行]						（实际行 g 开头）
"gj，gk									按屏幕行上下移动
"g0										移动到屏幕行行首
"g^										移动到屏幕行第一个非空字符串
"g$										移动到屏幕行行尾

"[基于单词的移动]
"w										下一个单词的开头
"b										当前单词/上一个单词的开头
"e										当前单词/下一个单词的结尾
"ge										上一个单词的结尾

"[基于字串的移动]
"W										
"B
"E
"gE

"[基于字符查找的移动]
"f{char}
"F{char}
"t{char}								正向查找，{char}所在之处的前一个字符
"T{char}								反向查找，{char}所在之处的后一个字符
";
",
"[注意]: 缺省<Leader> \ 与 , 按键调换

"[基于字串查找的移动]
"/pattern<CR>


"[分隔符文本对象选择]					(a，i) + (配对符,t)
"i{配对符}								配对符内的内容（inside）
"a{配对符}								包括配对符在内的内容（around）
"it										XML标签<xml>tags</xml>内部
"at										一对XML标签<xml>tags</xml>

"[范围文本对象选择]						(a，i) + (wW,sS,pP)
"iw										当前单词
"aw										当前单词及一个空格
"iW										当期字串
"aW										当前字串及一个空格
"is										当前句子
"as										当前句子及一个空格
"ip										当前段落
"ap										当前段落及一个空行


"[基于位置标记的跳转]
"m{a-z}									小写标记仅在每个缓冲区局部可见
"m{A-Z}									大写标记全局可见
"'{mark}								移动到标记所在行第一个非空字符
"`{mark}								移动到标记位置

"[vim的自动位置标记]（核心标记）
"` `									当前文件中，上次跳转动作之前的位置
"` .									上次修改的地方
"` ^									上次插入的地方
"` [									上次修改或复制的起始位置
"` ]									上次修改或复制的结束位置
"` <									上次高亮选区的起始位置
"` >									上次高亮选区的结束位置

"[在匹配括号间跳转]
"%										在一组开、闭括号间跳转。()，{}，[}
"matchit插件对%的增强					可以在配对的关键字间跳转

"[文件间跳转]（核心）____________________________
":jumps										查看跳转列表
"<C-i>										前进
"<C-o>										后退
"[count]G									跳转到指定行
"/pattern<CR> / ?pattern<CR> / n / N		跳转到一个模式
"%											跳转到匹配的配对符
"( / )										跳转到上一句/下一句的开头
"{ / }										跳转到上一段/下一段的开头
"H / M / L									跳转到屏幕最上方/正中间/最下方
"gf											跳转到光标下的文件（goto file）(需要path设置)
"<C-]>										跳转到光标下关键字的定义处（goto define）
"'{mark} / `{mark}							跳转到一个位置标记
"[注意]: 1.[count]G跳转到指定的行号也会被认为一次跳转，但每次向上或向下移动一行不算跳转
"		 2.每个单独的活动窗口拥有自己的一份跳转列表。

"[遍历修改列表]（核心）
":changes									查看缓冲区的修改列表
"g;											反向遍历修改列表（跳转到上次更改过的地方）
"g,											正向遍历修改列表
"gi											用`^标记恢复光标位置，并切换到出入模式（继续编辑）
"[注意]: 每个缓冲区一个修改列表

"[查找所有引用]（核心）
":vimgrep /pattern/ **						跳转到第一个匹配处,并创建quickfix列表
":cnext :cprev :cfirst :clast				跳转到某一项
":cnfile									跳转到下一个文件中的第一项
":cpfile									跳转到上一个文件中的最后一项
":cc N										跳转到第 N 项
":copen										打开quickfix窗口
":cclose									关闭guickfix窗口
":colder									撤销对quickfix列表的更新
":cnewer									反撤销，即redo重做
":cdo {cmd}									quickfix列表中每一行上执行{cmd}
":cfdo {cmd}								quickfix列表中每个文件上执行{cmd}
":cfdo update								保存文件，但仅限于文件中有改动时。
"[注意]: 在此之前，请设置m{A-Z}，用于返回。 :cfdo之前，:set hidden


"[寄存器]_________________________________________________________________________________________________________________________________
"[文本的剪切、复制、粘贴]___________________
"d，y，p									删除(delete)，复制(yank)，粘贴(put)
"P											大P将文本插入光标之前/在上一行插入
"gp											光标位置移到被粘贴出来的文本结尾
"gP											光标位置移到被粘贴出来的文本结尾

"[指定要用的寄存器]
" "{register}{operation}

"[查看寄存器内容]
":reg "{register}

"[无名寄存器]
" 不指定寄存器时的缺省

"[黑洞寄存器]
" "_d{motion}									删除文本而不将内容添加到任何寄存器

"[复制专用寄存器]
" "0											y{motion}同时拷贝至无名寄存器和复制专用寄存器

"[有名寄存器]
" "a - "z										26个英文字母
" "A - "Z										将新内容添加至相应寄存器内容之后

"[系统剪贴板]（核心）
" "+											外部程序复制、剪切到剪贴板的内容,与外部程序交互

"[选择专用寄存器]（核心）
" "*											主剪贴板，保存着上次被高亮选中的文本，鼠标中键可把它们粘贴出来。

"[表达式寄存器]
" "=											当从表达式寄存器获取内容时，vim跳转到命令行，并显示提示符”=“

"[其他寄存器]（只读寄存器）
" "%											当前文件名
" "#											轮换文件名
" ".											上次插入的文本
" ":											上次执行的Ex命令
" "/											上次查找的模式

"[用寄存器中的内容替换高亮选取]（核心）
"在可视模式下，使用 p 命令时，vim 将用指定的寄存器内容替换高亮选区的文本。被替换部分进入无名寄存器。

"[在插入模式中获取寄存器内容]（核心）
"<C-r>{register}								插入寄存器内容
"<C-r>"											插入无名寄存器
"<C-r>0											插入复制专用寄存器
"鼠标中建										插入高亮选取内容

"[与系统剪贴板进行交互]
"普通模式下，"+p								从系统剪贴板粘贴文本
"输入模式下，<Ctrl-Shift-v>						从系统剪贴板粘贴文本
"[注意]:
"1. 复制之前 :set paste
"2. 复制之后 :set paste!
"3. 或者 :set pastetoggle=<f5>


"[按键操作的保存，宏操作]_______________________
"[理念]
"就像黑白棋游戏一样，学会 vim 宏只需一分钟，但要穷其一生才能精通。

"[宏的录制]
"q												既是"录制"按钮，也是"停止"按钮
"q{register}									指定寄存器并开始录制操作宏
"q{大写字母}									给对应的宏追加命令，添加到对应寄存器原有内容之后

"[宏寄存器]
" a - z											26个字母

"[宏的执行]
"@{register}									执行指定寄存器的内容
"@@												重复最近调用的宏
"N@{register}									以串行方式执行宏（劣）
":[range]normal @{register}						在range的每一行上并行执行宏（优）
":argdo normal @{register}						在参数列表的所有缓冲区内并行执行宏（劣）
"q{register} {操作} :next q	 N@{register}		在参数列表的所有缓冲区内串行执行宏（优）
"[注意]:
"运行 ': *do' 命令前，启用 'hidden' 设置。

"[查看寄存器内容]
":reg {register}

"[vim 变量定义及迭代求值]
":let i=0										创建变量i，并赋值0
":echo i										查看变量i的值
"<C-r>=i<CR>									插入变量i的值
":let i+=1										累加i的值


"[模式]___________________________________________________________________________________________________________________________________
"[查找命令]
"/												调出正向查找提示符
"?												调出反向查找提示符
"n												跳至上一处匹配，查找方向和偏移不变
"N												跳至下一处匹配，查找方向和偏移不变
"gn												进入面向字符的可视模式，并选中下一处匹配{motion}
"gN												进入面向字符的可视模式，并选中上一处匹配{motion}
":%s///gn										统计当前模式的匹配个数
":vimgrep //g %									统计匹配数量，并将匹配放入quickfix列表


"[模式的元字符]
"添加在模式的结尾或开头以设置模式的属性
"\c												忽略大小写
"\C												强制区分大小写
"\e												将光标偏移到查找匹配的结尾

"[正则表达式]
"\v												very magic使正则表达式更像是Perl、Python或者Ruby所为

"[正则表达式说明符]
"[{{char}]										指定字符范围
"[^{char}]										对指定范围取反
"|												”或“
"\x												等价于[0-9a-fA-F]
"()												一个模式的子串，可用\1到\9来引用
"\0												引用整个模式
"<与>											用于匹配单词的边界
"\s												匹配空白符或换行符
"\w												匹配单词类字符，包括字母、数字、以及下划线
"\W												匹配除单词类字符以外的其他字符
"\zs											标志一个匹配的开始
"\ze											标志一个匹配的结束

"[按原义查找]
"\V												按原义查找文本，very nomagic搜索模式

"[查找时，需要转义的字符]
"1.正向查找（/），记得转义 /
"2.反向查找（?），记得转义 ?
"3.每次查找都要转义 \
"4.用编程的方式转义字符							escape({string}, {chars})
"步骤:
"	将需要查找的文本保存至寄存器中，如寄存器u
"	输入 / 或 ? 调出查找提示符
"	依次输入原义开关\V与<C-r>=
"	输入escape(@u, getcmdtype().'\')			等价与escape(@u,'/\')


"[substitute]（最强大Ex命令之一）___________________________________________________________________________
"[说明] 1. :substitute命令很复杂，除了要提供查找的模式以及替换字符串外，还要指定执行的范围。
"		2. 另外，作为可选项，还可以通过标志位来调整该命令的行为。
"[语法] :[range]s/{pattern}/{string}/[flags]

"[flags]
"g									可以修改一行内的所有匹配项，而不仅仅是第一处匹配
"c									使有机会可以确认或拒绝每一处修改			
"n									让vim不执行替换操作，仅仅报告本次匹配的个数
"e									屏蔽没有找到匹配项时的报错信息
"&									指示vim重用上一次substitute使用的标志位

"[替换域中的特殊字符]
"\r									换行符
"\t									制表符
"\\									反斜杠
"\1									第1个子匹配
"\2									第2个子匹配（以此类推，最多到\9）
"\0									匹配模式的所有内容
"&									匹配模式的所有内容
"~									使用上次调用:substitute时的{string}
"\={vim script}						执行{vim script}表达式，并将返回结果作为替换{string}

"[重用上次的查找模式]
"将substitute命令的查找域留空，意味着vim将会重用上次的查找模式。
"<C-r>/								把上次的查找内容粘贴进命令行

":let @/='Pragmatic Vim'			采用编程的方式输入查找模式
":let @a='Practical Vim'			设置a寄存器的内容

"[重复上一次的substitute命令]
":&&								:&重复substitute命令，&重用:s命令的标志位

"[在整个文件范围内重复面向行的替换操作]
"g&									等同于 :%s//~/& 是 :%&&的快捷方式


"[global]（强大查找+执行）___________________________________________________________________________________
"[功能] :global允许在某个指定模式的所有匹配行上执行Ex命令。用于Ex命令和模式匹配功能的结合。
"[语法] :[range] global[!] /{pattern}/ [cmd]
"[说明] 缺省情况下，:global作用于整个文件（%），如果不提供{cmd}，缺省使用:print

":global! 或 :vglobal				指示vim在没有匹配模式的行上执行{cmd}

"[Ex命令与:global一起使用时，也可以为[cmd]单独指定范围]
":g/{pattern}/[range][cmd]
"[范式]
":g/{start}/ .,{finish} [cmd]

"[使用:g把多行内容复制到寄存器a]
":qaq								清空寄存器a
":g/{pattern}/yank A				将匹配行复制到寄存器

"[grep的由来]
":g/re/p							:global regular expression :print


"[自动补全]_______________________________________________________________________________________________________________________________
"<C-n>								普通关键字
"<C-x><C-n>							当前缓冲区关键字
"<C-x><C-i>							包含文件关键字
"<C-x><C-]>							标签文件关键字
"<C-x><C-k>							字典查找
"<C-x><C-l>							整行补全
"<C-x><C-f>							文件名补全
"<C-x><C-o>							全能(Omni)补全（根据上下文自动补全）

"[与补全列表交互]
"<C-n>								下一个匹配项
"<C-p>								上一个匹配项
"<C-y>								确认当前项
"<C-e>								从自动补全退出
"<C-h> 或 <BS>						从当前匹配项中删除一个字符								
"<C-l>								从当前匹配项中增加一个字符
"{char}								终止自动补全，并插入字符{char}

"[自动补全单词序列]
"<C-x><C-p>

"_________________________________________________________________________________________________________________________________________
set shiftwidth=4
set softtabstop=4
set expandtab

"启用wildmenu,vim会提供一个补全导航列表
set wildmenu
"以bash shell的方式执行补全行为
set wildmode=longest,list
"回溯历史命令，:下<Up><Down>回溯历史
"回溯查找历史，/下<Up><Down>回溯pattern
set history=200

"%%轻松展开当前文件所在的目录
cnoremap <expr> %% getcmdtype() == ':' ? expand('%:h').'/':'%%'
"设置:find查找路径
set path+=**/**

"设置vim可加载插件
set nocompatible
filetype plugin on

"用于改掉使用光标键的习惯
noremap <Up> <Nop>
noremap <Down> <Nop>
noremap <Left> <Nop>
noremap <Right> <Nop>

"<Leader>用户自定义命令的名字空间，缺省<Leader>是 \
let mapleader=","
noremap \ ,
noremap <Leader>n nzz
noremap <Leader>N Nzz

"激活自带的matchit插件，增强%使在关键字间跳转
runtime macros/matchit.vim

"配置gf命令的环境(go to file),指定文件的后缀名
set suffixesadd+=.rb
"查看path的值
":set path?

"paste选项的启用、关闭，用于系统剪贴板交互
set pastetoggle=<f5>

"高亮查找功能
set hlsearch
"取消当前高亮显示
"set hls!
"禁用高亮显示功能
"set nohls

"<C-l>清除并重绘屏幕，增添暂时关闭查找高亮功能
nnoremap <silent> <C-l> :<C-u>nohlsearch<CR><C-l>

"查找前预览第一处匹配
set incsearch

"vim模式查找大小写敏感性
"set ignorecase
"全小写为忽略大小写，出现大写为强制区分大小写
set smartcase

"*查找命令功能增强，或者安装插件visual-star-search
xnoremap * :<C-u>call <SID>VSetSearch('/')<CR>/<C-R>=@/<CR><CR>
xnoremap # :<C-u>call <SID>VSetSearch('?')<CR>?<C-R>=@/<CR><CR>

function! s:VSetSearch(cmdtype)
	let temp = @s
	norm! gv"sy
	let @/ = '\V' . substitute(escape(@s, a:cmdtype.'\'), '\n', '\\n', 'g')
	let @s = temp
endfunction

"修正普通模式下的 & 命令
nnoremap & :&&<CR>
xnoremap & :&&<CR>


"定制自动补全，缺省设置complete=.,w,b,u,t,i
set complete+=k

